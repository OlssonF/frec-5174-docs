# Process model

```{r}
#| message = FALSE
#| 
source("R/helpers.R")
library(tidyverse)
library(lubridate)
```

- timestep: 1 day
- currency: MgC/ha 
- dimension: 0-D

```{r}
forest_model <- function(t, states, parms, inputs){
  
  ens_members <- nrow(states)
  
  inputs_temp <- inputs[, 1]
  inputs_PAR <- inputs[, 2]
  inputs_doy <- inputs[, 3]
  
  # Unit Conversion: umol/m2/sec to Mg/ha/timestep
  k <- 1e-6 * 12 * 1e-6 * 10000 * 86400 #mol/umol*gC/mol*Mg/g*m2/ha*sec/timestep


  
  # Convert leaf carbon to leaf area index
  lai <- states[, 1] * parms$SLA * 0.1  #0.1 is conversion from Mg/ha to kg/m2
  
  # photosynthesis
  #Calculate gross primary productivity as a function of LAI and PAR (convert to daily)
  ## pmax ensures GPP never goes negative
  gpp <- pmax(0, k * parms$alpha * (1 - exp(-0.5 * lai)) * inputs_PAR)

  ## autotropic respiration & allocation to leaves and wood
  ra <- gpp * parms$Ra_frac
  npp <- gpp - ra
  
  leaf_alloc <- npp * parms$leaf_frac
  wood_alloc <- npp * (1 - parms$leaf_frac)

  # Calculate soil respiration using a base rate and a Q10 temperature modifier 
  #(more soil = more respiration, hotter = more respiration)
  ## pmax ensures SOM never goes negative
  rh <- pmax(k * parms$Rbasal * states[, 3] * parms$Q10 ^ (inputs_temp / 10), 0) 

  ## turnover

  #calculate the daily rate of leaf drop
  litterfall <- states[ , 1] * (parms$litterfall_rate * (365/ (params$litterfall_length)))
  #Not leaf drop if outside the day of year window
  litterfall[!(inputs_doy > params$litterfall_start & inputs_doy[1] < (params$litterfall_start + params$litterfall_length))] <- 0.0
  
  #kill trees
  mortality <- states[ , 2] * parms$mortality
  
  #Change in states
  dleaves_dt <- leaf_alloc  - litterfall
  dwood_dt <- wood_alloc  - mortality
  dSOM_dt <- litterfall + mortality - rh
  
  #Update states by adding the change
  states[, 1] <- states[, 1] + dleaves_dt
  states[, 2] <- states[, 2] + dwood_dt
  states[, 3] <- states[, 3] + dSOM_dt
  
  ## Add normally distributed random noise to states
  ## pmax ensures states never goes negative
  states[, 1] <- pmax(rnorm(ens_members, states[, 1] , parms$sigma.leaf), 0)
  states[, 2] <- pmax(rnorm(ens_members, states[, 2], parms$sigma.stem), 0)
  states[, 3] <- pmax(rnorm(ens_members, states[, 3], parms$sigma.soil), 0)
  
  #Dervived variables (LAI and net ecosystem exchange)
  lai <- states[, 1]  * parms$SLA * 0.1
  nee <- -(gpp - ra - rh)
  
  return(cbind(state1 = states[, 1],
              state2 = states[, 2],
              state3 = states[, 3],
              lai = lai,
               gpp = gpp ,
               nee = nee,
               ra =  ra,
               npp_w = wood_alloc,
               npp_l = leaf_alloc,
               rh = rh,
               litterfall = litterfall,
               mortality = mortality))

}
```

## Set up model run

### Time frame, site id, and number of ensembles

We are doing a deterministic simulation (no uncertainty) so we only have one ensemble member

```{r}
site <- "TALL"
ens_members <- 1
sim_dates <- seq(as_date("2020-09-30"), Sys.Date() - lubridate::days(1), by = "1 day")
```

### Set drivers

There is a custom function to access the weater drivers.  You can learn more about the function in the appendix (add link)

```{r}
inputs <- get_historical_met(site = site, sim_dates, use_mean = TRUE)
inputs_ensemble <- assign_met_ensembles(inputs, ens_members)
```

### Set parameters

```{r}
#Set parameters
params <- list()
params$alpha <- rep(0.02, ens_members)
params$SLA <- rep(4.74, ens_members)
params$leaf_frac <- rep(0.315, ens_members)
params$Ra_frac <- rep(0.5, ens_members)
params$Rbasal <- rep(0.002, ens_members)
params$Q10 <- rep(2.1, ens_members)
params$litterfall_rate <- rep(1/(2.0*365), ens_members) #Two year leaf lifespan
params$litterfall_start <- rep(200, ens_members)
params$litterfall_length<- rep(60, ens_members)
params$mortality <- rep(0.00015, ens_members) #Wood lives about 18 years on average (all trees, branches, roots, course roots)
params$sigma.leaf <- rep(0.0, ens_members) #0.01 
params$sigma.stem <- rep(0.0, ens_members) #0.01 ## wood biomass
params$sigma.soil <- rep(0.0, ens_members)# 0.01
params <- as.data.frame(params)
```

### Set inital condition

Set the starting point of the simulation.  All states need a starting point.

```{r}
output <- array(NA, dim = c(length(sim_dates), ens_members, 12)) #12 is the number of outputs
output[1, , 1] <- 5
output[1, , 2] <- 140
output[1, , 3] <- 140
```

## Run model

```{r}
for(t in 2:length(sim_dates)){
  output[t, , ]  <- forest_model(t, 
                               states = matrix(output[t-1 , , 1:3], nrow = ens_members) , 
                               parms = params, 
                               inputs = matrix(inputs_ensemble[t ,, ], nrow = ens_members))
}
```

## Plot output

The `output_to_df` converts the output into a data frame.

```{r}
output_df <- output_to_df(output, sim_dates, sim_name = "baseline")
```

Plot the data frame.

```{r}
#| warning = FALSE
#| message = FALSE
output_df |> 
  filter(variable %in% c("lai", "wood", "som", "nee")) |> 
  ggplot(aes(x = datetime)) +
  geom_point(aes(y = prediction, group = ensemble)) +
  facet_wrap(~variable, scale = "free")
```
