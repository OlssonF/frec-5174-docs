# Parameter calibration: Applying to process model

```{r}
#| echo: FALSE
source("R/helpers.R")
source("R/forest_model.R")
```

```{r}
library(tidyverse)
site <- "TALL"
met_s3 <- arrow::s3_bucket(paste0("bio230014-bucket01/neon4cast-drivers/noaa/gefs-v12/stage3/site_id=", site),
                           endpoint_override = "sdsc.osn.xsede.org",
                           anonymous = TRUE)

inputs_all <- arrow::open_dataset(met_s3) |> 
  filter(variable %in% c("air_temperature", "surface_downwelling_shortwave_flux_in_air")) |> 
  mutate(datetime = as_date(datetime)) |> 
  mutate(prediction = ifelse(variable == "surface_downwelling_shortwave_flux_in_air", prediction/0.486, prediction),
         variable = ifelse(variable == "surface_downwelling_shortwave_flux_in_air", "PAR", variable),
         prediction = ifelse(variable == "air_temperature", prediction- 273.15, prediction),
         variable = ifelse(variable == "air_temperature", "temp", variable)) |> 
  summarise(prediction = mean(prediction, na.rm = TRUE), .by = c("datetime", "variable")) |> 
  mutate(parameter = 1) |> 
  collect()
```


```{r}
obs <- read_csv("data/site_carbon_data.csv", show_col_types = FALSE)
```


```{r}
library(tidyverse)
library(patchwork)
set.seed(100)

#Set MCMC Configuration
num_iter <- 1000
ens_members <- 1

log_likelihood_prior_current <- -10000000000
accept <- 0

sim_dates <- seq(as_date("2023-01-01"), Sys.Date() - 1, by = "1 day")


params <- list()
params$alpha <- rep(0.02, ens_members)
params$SLA <- rep(4.74, ens_members)
params$leaf_frac <- rep(0.315, ens_members)
params$Ra_frac <- rep(0.5, ens_members)
params$Rbasal <- rep(0.002, ens_members)
params$Q10 <- rep(2.1, ens_members)
params$litterfall <- rep(1/(365*2), ens_members) #Two year leaf lifespan
params$mortality <- rep(0.00015, ens_members) #Wood lives about 18 years on average (all trees, branches, roots, course roots)
params$sigma.leaf <- rep(0.0, ens_members) #0.01 
params$sigma.stem <- rep(0.0, ens_members) #0.01 ## wood biomass
params$sigma.soil <- rep(0.0, ens_members)# 0.01
params <- as.data.frame(params)

#Initialize chain
num_pars <- 2
jump_params <- c(0.002, 0.0002)
fit_params <- array(NA, dim = c(num_pars, num_iter))
fit_params[1, 1] <- params$alpha
fit_params[2, 1] <- params$Rbasal
prior_mean <- c(0.029, 0.002)
prior_sd <- c(0.005, 0.0005)
  
state_init <- rep(NA, 3)

state_init[1] <- obs |> 
  filter(datetime %in% sim_dates,
         variable == "lai") |> 
  na.omit() |> 
  summarise(observation = mean(observation, na.rm = TRUE)) |> 
  mutate(observation = observation / (mean(params$SLA) * 0.1)) |> 
  pull(observation)

state_init[2] <- obs |> 
  filter(variable == "wood") |> 
  na.omit() |> 
  slice(1) |> 
  pull(observation)

state_init[3] <- obs |> 
  filter(variable == "som") |> 
  na.omit() |> 
  slice(1) |> 
  pull(observation)

inputs <- inputs_all |> 
    filter(datetime %in% sim_dates)
inputs_ensemble <- assign_met_ensembles(inputs, ens_members = 1)


for(iter in 2:num_iter){
  
  #Loop through parameter value
  
  for(j in 1:num_pars){
    
    proposed_pars <- fit_params[, iter - 1]
    proposed_pars[j] <- rnorm(1, mean = fit_params[j, iter - 1], sd = jump_params[j])
    
    log_prior <- dnorm(proposed_pars[1], mean = prior_mean[1], sd = 0.005, log = TRUE) + 
      dnorm(proposed_pars[2], mean = prior_mean[2], sd = 0.0005, log = TRUE)
    
    params$alpha  <- proposed_pars[1]
    params$Rbasal  <- proposed_pars[2]
    
    #Set initial conditions
    output <- array(NA, dim = c(length(sim_dates), ens_members, 12)) #12 is the number of outputs
    output[1, , 1] <- state_init[1]
    output[1, , 2] <- state_init[2]
    output[1, , 3] <- state_init[3]
    
    for(t in 2:length(sim_dates)){
      output[t, , ]  <- forest_model(t, 
                                     states = matrix(output[t-1 , , 1:3], nrow = ens_members) , 
                                     parms = params, 
                                     inputs = matrix(inputs_ensemble[t ,, ], nrow = ens_members))
    }
    
    output_df <- output_to_df(output, sim_dates, sim_name = "fitting")
    
    combined_output_obs <- combine_model_obs(output_df, 
                                             obs,
                                             variables = c("lai", "wood", "som", "nee"), 
                                             #variables = c("nee"), 
                                             #sds = c(0.01))
                                             sds = c(0.5, 20, 20, 0.01))
    
    log_likelihood <- sum(dnorm(x =  combined_output_obs$observation, 
                                mean = combined_output_obs$prediction, 
                                sd = combined_output_obs$sds, log = TRUE))
    
    log_likelihood_prior_proposed <- log_prior + log_likelihood
    
    z <- exp(log_likelihood_prior_proposed - log_likelihood_prior_current)
    
    r <- runif(1, min = 0, max = 1)
    
    if(z >  r){
      fit_params[j, iter] <- proposed_pars[j]
      log_likelihood_prior_current <- log_likelihood_prior_proposed
      accept <- accept + 1
    }else{
      fit_params[j, iter] <- fit_params[j, iter - 1]
      log_likelihood_prior_current <- log_likelihood_prior_current #this calculation isn't necessary but is here to show you the logic
    }
  }
}

accept / (num_iter * num_pars)

```

```{r}
nburn <- 500
d <- tibble(iter = nburn:num_iter,
            par1 = fit_params[1, nburn:num_iter],
            par2 = fit_params[2, nburn:num_iter]) %>%
  pivot_longer(-iter, values_to = "value", names_to = "parameter")

p1 <- ggplot(d, aes(x = iter, y = value)) +
  geom_line() +
  facet_wrap(~parameter, scales = "free")

p2 <- ggplot(d, aes(x = value)) +
  geom_histogram() +
  facet_wrap(~parameter, scales = "free")

p1 / p2
```

```{r}
ens_members <- 100

inputs_ensemble <- assign_met_ensembles(inputs, ens_members = ens_members)


#Set initial conditions
output <- array(NA, dim = c(length(sim_dates), ens_members, 12)) #12 is the number of outputs
output[1, , 1] <- state_init[1]
output[1, , 2] <- state_init[2]
output[1, , 3] <- state_init[3]

params <- list()
params$alpha <- rnorm(ens_members, mean = prior_mean[1], sd = prior_sd[1])
params$SLA <- rep(4.74, ens_members)
params$leaf_frac <- rep(0.315, ens_members)
params$Ra_frac <- rep(0.5, ens_members)
params$Rbasal <- rnorm(ens_members, mean = prior_mean[2], sd = prior_sd[2])
params$Q10 <- rep(2.1, ens_members)
params$litterfall <- rep(1/(365*2), ens_members) #Two year leaf lifespan
params$mortality <- rep(0.00015, ens_members) #Wood lives about 18 years on average (all trees, branches, roots, course roots)
params$sigma.leaf <- rep(0.0, ens_members) #0.01 
params$sigma.stem <- rep(0.0, ens_members) #0.01 ## wood biomass
params$sigma.soil <- rep(0.0, ens_members)# 0.01
params <- as.data.frame(params)

for(t in 2:length(sim_dates)){
  
  output[t, , ]  <- forest_model(t, 
                                 states = matrix(output[t-1 , , 1:3], nrow = ens_members) , 
                                 parms = params, 
                                 inputs = matrix(inputs_ensemble[t ,, ], nrow = ens_members))
}

output_df_no_optim <- output_to_df(output, sim_dates, sim_name = "no_optim")
```

```{r}

#Set initial conditions
output <- array(NA, dim = c(length(sim_dates), ens_members, 12)) #12 is the number of outputs
output[1, , 1] <- state_init[1]
output[1, , 2] <- state_init[2]
output[1, , 3] <- state_init[3]

params <- list()
params$alpha <- rep(0.02, ens_members)
params$SLA <- rep(4.74, ens_members)
params$leaf_frac <- rep(0.315, ens_members)
params$Ra_frac <- rep(0.5, ens_members)
params$Rbasal <- rep(0.002, ens_members)
params$Q10 <- rep(2.1, ens_members)
params$litterfall <- rep(1/(365*2), ens_members) #Two year leaf lifespan
params$mortality <- rep(0.00015, ens_members) #Wood lives about 18 years on average (all trees, branches, roots, course roots)
params$sigma.leaf <- rep(0.0, ens_members) #0.01 
params$sigma.stem <- rep(0.0, ens_members) #0.01 ## wood biomass
params$sigma.soil <- rep(0.0, ens_members)# 0.01
params <- as.data.frame(params)

#params$alpha <- rep(mean(fit_params[1, nburn:num_iter]), ens_members)
#params$litterfall <- rep(mean(fit_params[2, nburn:num_iter]), ens_members)

params$alpha <- sample(fit_params[1, nburn:num_iter], ens_members, replace = TRUE)
params$Rbasal <- sample(fit_params[2, nburn:num_iter], ens_members, replace = TRUE)

for(t in 2:length(sim_dates)){
  
  output[t, , ]  <- forest_model(t, 
                                 states = matrix(output[t-1 , , 1:3], nrow = ens_members) , 
                                 parms = params, 
                                 inputs = matrix(inputs_ensemble[t ,, ], nrow = ens_members))
}

output_df_optim <- output_to_df(output, sim_dates, sim_name = "optimized")

```

```{r}
bind_rows(output_df_no_optim, output_df_optim) |> 
  filter(variable %in% c("lai", "wood", "som", "nee")) |> 
  mutate(ensemble = paste0(ensemble,"_",model_id)) |> 
  ggplot(aes(x = datetime)) +
  geom_line(aes(y = prediction, group = ensemble, color = model_id), alpha = 0.2) +
  geom_point(data = obs, aes(x = datetime, y = observation), color = "gray", alpha = 0.7) +
  xlim(min(output_df_no_optim$datetime), max(output_df_no_optim$datetime)) + 
  facet_wrap(~variable, scale = "free")
```

```{r}
tibble(iter = nburn:num_iter,
       alpha = fit_params[1, nburn:num_iter],
       Rbasal = fit_params[2, nburn:num_iter]) |> 
  pivot_longer(-iter, values_to = "value", names_to = "parameter") |> 
  write_csv("data/saved_parameter_chain.csv")
  

```
